= stylesheet_link_tag 'network'

:plain 
  <canvas id="canvas" width="2600px" height="1400px"></canvas>

.scenarios
  - @scenarios.each do |scenario|
    .scenario_object{ :id => "scenario_#{scenario.id}", :style => "left: #{scenario.left}px; top: #{scenario.top}px" }
      = scenario.title
      .steps_link{ :id => "scenario_#{scenario.id}_steps_link" }
      .steps{ :id => "scenario_#{scenario.id}_steps", :style => "display:none;" }
        = raw scenario.steps.gsub(/\\n/, '<br />').gsub(/(Given|When|Then|And)/, '<font color=green>\1</font>')
.tags
  - @scenarios.collect{|s| s.tags}.flatten.uniq.each do |tag|
    .tag_object{ :id => "tag_#{tag.id}", :style => "left: #{tag.left}px; top: #{tag.top}px; background-color: #{cycle('blue','red','green')}" }
      = tag.name



.link_bar
  = link_to 'New Scenario', new_scenario_path
  = link_to 'Randomly Arrange Items', "#", :id => 'randomize'

  
-#%ul.features
  %li= link_to 'Show', scenario
  %li= link_to 'Edit', edit_scenario_path(scenario)
  %li= button_to 'Destroy', scenario_path(scenario),  :confirm => 'Are you sure?', :method => :delete

:javascript 
  var canvas = $('#canvas')[0]
  var ctx = canvas.getContext('2d');
  var connections = [ #{@scenarios.collect { |s| s.tags.collect { |t| "{ from: '#scenario_" + s.id.to_s + "', to: '#tag_" + t.id.to_s + "' }" } }.join(', ') } ];

  function connect(scen, tag) { 
    scen = $(scen);
    tag = $(tag);
    ctx.beginPath();
    ctx.moveTo(scen.offset().left + scen.width()/2, scen.offset().top + scen.height()/2);
    ctx.lineTo(tag.offset().left + tag.width()/2, tag.offset().top + tag.height()/2);
    ctx.strokeStyle = tag.css('background-color');
    ctx.stroke();
  }

  function colinear(start, end, point, error)  {
    //get crossproduct
    val =  ((end.x - start.x) * (point.y - start.y)) - ((point.x - start.x) * (end.y - start.y))
    console.debug(val)
    if(Math.abs(val) <= error)  {
      return true;
    }
    return false;
  }

  function inside_bounding_box(start, end, point, error)  {
    //if abs is slow, negate end and add the or
    if((
        (start.x + error >= point.x && point.x >= end.x - error) 
        || (end.x + error >= point.x && point.x >= start.x - error)
      ) && (
        (start.y + error >= point.y && point.y >= end.y - error) 
        || (end.y + error >= point.y && point.y >= start.y - error)
      ))  {
      return true;
    }
    return false;
  }

  $('#canvas').click(function(e)  {
    click = { x: e.pageX + $('canvas').offset().left, y: e.pageY + $('canvas').offset().top }
    console.debug(click.x + ", " + click.y);
    $.each(connections, function(index, value)  {
      console.debug(value.from + ", " + value.to);
      f = $(value.from);
      t = $(value.to);
      from = { x: f.offset().left + f.width()/2, y: f.offset().top + f.height()/2 };
      to = { x: t.offset().left + t.width()/2, y: t.offset().top + t.height()/2 };
      allowable_error = 3; //3 pixels
      if( inside_bounding_box(from, to, click, allowable_error))  {
        console.debug("inside bounding box " + from.x + ":" + from.y +":"+ to.x +":"+ to.y +":"+ click.x +":"+ click.y);
        ctx.strokeRect(from.x, from.y, to.x-from.x, to.y-from.y)
        if(colinear(from, to, click, allowable_error))  {
          console.debug("colinear");
        }
      }
    });
  });

  #{@scenarios.collect { |scenario| scenario.tags.collect { |tag| "connect('#scenario_" + scenario.id.to_s + "', '#tag_" + tag.id.to_s + "');" } } }

  function update_canvas() {
    canvas.width = canvas.width;
    #{@scenarios.collect { |scenario| scenario.tags.collect { |tag| "connect('#scenario_" + scenario.id.to_s + "', '#tag_" + tag.id.to_s + "');" } } }
  }

  function randomize() { 
    $('.scenario_object, .tag_object').each(function() { 
      $(this).css('left', Math.random()*1024); $(this).css('top', Math.random()*768); 
      save_position($(this));
    });
    update_canvas();
    return false;
  }
  
  function save_position(element) {
    var url = '', post_data = '', type = '', id = ''

    // determine which type of element we are dragging
    type = element.attr('class').match(/([^ ]+)_object/)[1];

    id = element.attr('id').replace(type+'_', '');
      
    url = '/' + type + 's/' + id + '.json';
    post_data = "_method=put" +
                "&" + type + "[left]=" + element.offset().left +
                "&" + type + "[top]=" + element.offset().top;

    $.post(url, post_data, function(d,t){
      window.r = d;
      update_canvas();
    });
  }

  $('#randomize').click(randomize);

  //sets z index high when dragging, and below a click when done dragging
  $('.scenario_object, .tag_object').draggable({
    drag: function(e,ui) { update_canvas(); $(this).css('z-index', 1000)},
    stop: function(e, ui) { 
      save_position(ui.helper);
      $(this).css('z-index', 499);
   }
  });

  //sets to high z-index but lower than dragging index
  $('.scenario_object, .tag_object').click(function()  {
    $(this).css('z-index', 500);
  });

  //hides the steps, show the step link
  $('.steps').click(function(){
    steps_link_div = $(this).attr('id') + '_link';
    $(this).css('display', 'none');
    $('#' + steps_link_div).css('display', 'block');
    update_canvas();
  });
  
  //hide the link, show the steps
  $('.steps_link').click(function(){
    steps_div = $(this).attr('id').replace('_link', '');
    $(this).css('display', 'none');
    $('#' + steps_div).css('display', 'block');
    update_canvas();
  });


